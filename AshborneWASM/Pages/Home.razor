@using AshborneGame._Core.Game
@using AshborneGame._Core.SceneManagement;
@using AshborneGame._Core.Globals.Constants
@using AshborneGame._Core.Globals.Services
@using System.Diagnostics;
@using AshborneGame.WebPort
@using Microsoft.JSInterop
@page "/"
@inject IJSRuntime JS

<h1 class="text-center">ASHBORNE</h1>

<div class="game-screen">
    <div class="game-output">@gameText</div>

    @if (isAwaitingPlayerInput)
    {
        <input @bind="userInput"
               @bind:event="oninput"
               @onkeydown="HandleInput"
               placeholder="@(isDialogueInput ? "What do you say?" : "What will you do?")" autofocus />
        <div><em>Type your response and press Enter.</em></div>
    }
    else if (isInDialogue && dialogueChoices.Count > 0 && !isTypingDialogue)
    {
        <div class="dialogue-choices">
            <p>Choose an option:</p>
            @for (int i = 0; i < dialogueChoices.Count; i++)
            {
                int choiceIndex = i; // Capture the index for the lambda
                                     <button @onclick="() => SelectDialogueChoice(choiceIndex + 1)" class="choice-button">
                                         [@(choiceIndex + 1)] @dialogueChoices[i]
                                     </button>
            }
        </div>
    }
    else if (!isInDialogue)
    {
        <input @bind="userInput"
               @bind:event="oninput"
               @onkeydown="HandleInput"
               placeholder="What will you do?" />
        <div><em>Type your action and press Enter.</em></div>
    }
    else
    {
        <div class="dialogue-waiting">
            <p>Listening...</p>
        </div>
    }
</div>

<div>
    <pre>
        isInDialogue: @isInDialogue
        isAwaitingPlayerInput: @isAwaitingPlayerInput
        dialogueChoices.Count: @dialogueChoices.Count
        isTypingDialogue: @isTypingDialogue
    </pre>
</div>

@code {
    [Inject] private HttpClient? Http { get; set; }
    [Inject] private NavigationManager? Navigation { get; set; }
    [Inject] private AppEnvironment? AppEnv { get; set; }
    private string userInput = "";
    private string gameText = "";
    private GameEngine engine;
    private bool isInDialogue = false;
    private bool isTypingDialogue = false;
    private List<string> dialogueChoices = new List<string>();
    private TaskCompletionSource<int> choiceCompletionSource;
    private bool isAwaitingPlayerInput = false;
    private bool isDialogueInput = false;
    private TaskCompletionSource<string> playerInputTcs;
    private TaskCompletionSource<bool> choicesAvailableTcs;

    // Output queue for all output (lines, pauses, typewriter)
    private Queue<string> outputQueue = new Queue<string>();
    private bool isProcessingQueue = false;

    // Static instance for external access (used by InkRunner flush)
    public static Home? Instance;

    protected override void OnInitialized()
    {
        Instance = this;
        if (AppEnv == null)
        {
            throw new InvalidOperationException("AppEnvironment is not injected.");
        }
#if DEBUG
        var outputHandler = new WebOutputHandler(
            async line => EnqueueOutput(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); },
            async (type, msg) => EnqueueOutput($"[DEBUG - {type}]: {msg}")
        );
#else
        var outputHandler = new WebOutputHandler(
            async line => EnqueueOutput(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); }
        );
#endif

        var inputHandler = new WebInputHandler(
            async () => await Task.FromResult(userInput),
            async (choiceCount) => await GetDialogueChoice(choiceCount)
        );

        engine = new GameEngine(inputHandler, outputHandler, AppEnv);

        // Wire up callbacks for dialogue and player input
        if (GameContext.DialogueService != null)
        {
            GameContext.DialogueService.SetPlayerInputCallback(GetPlayerInputFromUIAsync);
            GameContext.DialogueService.DialogueComplete += async () =>
            {
                isInDialogue = false;
                isAwaitingPlayerInput = false;
                userInput = "";
                await InvokeAsync(StateHasChanged);
            };
            GameContext.DialogueService.DialogueStart += async () =>
            {
                isInDialogue = true;
                isAwaitingPlayerInput = false;
                userInput = "";
                await InvokeAsync(StateHasChanged);
            };
        }

        // Start the game without the blocking loop
        engine.StartGameLoopAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Auto-scroll to bottom on initial page load
            await Task.Delay(100); // Small delay to ensure DOM is ready
            await AutoScrollToBottom();
        }
    }

    private void ResetInput()
    {
        isAwaitingPlayerInput = false;
        userInput = "";
        isDialogueInput = false;
        InvokeAsync(StateHasChanged);
    }

    // Enqueue output for sequential processing
    private void EnqueueOutput(string line)
    {
#if DEBUG
        Console.WriteLine($"[DEBUG] EnqueueOutput: {line}");
#endif
        outputQueue.Enqueue(line);
        if (!isProcessingQueue)
        {
            _ = ProcessOutputQueue();
        }
    }

    /// <summary>
    /// Waits until the output queue is fully processed. Used to synchronize output and input.
    /// </summary>
    public async Task FlushOutputQueueAsync()
    {
        // Wait until the output queue is empty and not processing
        while (outputQueue.Count > 0 || isProcessingQueue)
        {
            await Task.Delay(1);
        }
    }

    private async Task ProcessOutputQueue()
    {
        isProcessingQueue = true;
        while (outputQueue.Count > 0)
        {
            var line = outputQueue.Dequeue();
#if DEBUG
            Console.WriteLine($"[DEBUG] ProcessOutputQueue: {line}");
#endif
            // Handle special pause marker: ms__PAUSE__
            if (line.TrimEnd().EndsWith("__PAUSE__"))
            {
                var msStr = line.Substring(0, line.IndexOf("__PAUSE__"));
                if (int.TryParse(msStr, out int ms))
                {
                    await InvokeAsync(StateHasChanged);
                    await Task.Yield();
                    await Task.Delay(ms);
                }
                else
                {
                    await InvokeAsync(StateHasChanged);
                    await Task.Yield();
                    await Task.Delay(OutputConstants.DefaultPauseDuration);
                }
                continue; // Do not add pause marker to output buffer
            }
            // Handle typewriter effect
            if (line.Contains("__TYPEWRITER_START__") && line.Contains("__TYPEWRITER_END__"))
            {
                await HandleTypewriterEffect(line);
                continue;
            }
            // Dialogue choice line
            if (line.Trim().StartsWith("[") && line.Contains("]") && line.Trim().Length > 2)
            {
                int bracketEnd = line.IndexOf("]");
                if (bracketEnd > 0 && int.TryParse(line.Substring(1, bracketEnd - 1), out int choiceNumber))
                {
                    string choiceText = line.Substring(bracketEnd + 1).Trim();
                    if (!string.IsNullOrWhiteSpace(choiceText))
                    {
                        dialogueChoices.Add(choiceText);
                        await InvokeAsync(StateHasChanged);
                        await AutoScrollToBottom();
                        continue;
                    }
                }
            }
            // Normal line
            if (!string.IsNullOrWhiteSpace(line))
            {
                gameText += line + "\n";
            }
            else
            {
                gameText += "\n";
            }
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();
        }
        isProcessingQueue = false;
    }

    private async Task HandleTypewriterEffect(string line)
    {
        // Parse ms value at the start of the line (e.g. "50__TYPEWRITER_START__...")
        int ms = 30; // default
        int msEnd = line.IndexOf("__TYPEWRITER_START__");
        if (msEnd > 0)
        {
            string msStr = line.Substring(0, msEnd);
            if (!int.TryParse(msStr, out ms)) ms = 30;
        }
        int startIndex = line.IndexOf("__TYPEWRITER_START__") + "__TYPEWRITER_START__".Length;
        int endIndex = line.IndexOf("__TYPEWRITER_END__");
        string message = line.Substring(startIndex, endIndex - startIndex);

        isTypingDialogue = true;
        await InvokeAsync(StateHasChanged);

        // Split into lines and type each line separately
        string[] lines = message.Split('\n');
        var buffer = gameText.Split('\n').ToList(); // Keep previous lines

        foreach (var msgLine in lines)
        {
            string typedLine = "";
            for (int i = 0; i < msgLine.Length; i++)
            {
                typedLine += msgLine[i];
                gameText = string.Join('\n', buffer) + (buffer.Count > 0 ? "\n" : "") + typedLine;
                await InvokeAsync(StateHasChanged);
                await AutoScrollToBottom();
                char letter = msgLine[i];
                bool isEnd = message.Count() == i + 1 || message[i + 1].Equals(' ') || (i + 2 == message.Length && message.Substring(i + 1).Equals("\n")); // Check if this is the end of the message or sentence
                
#if DEBUG
                await Task.Delay(CharacterOutputDelayCalculator.CalculateDebugDelay(letter, ms, isEnd));
#else
                await Task.Delay(CharacterOutputDelayCalculator.CalculateDelay(letter, ms, isEnd));
#endif
            }
            buffer.Add(typedLine); // Add finished line to buffer
            gameText = string.Join('\n', buffer);
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();

#if DEBUG
            await Task.Delay(Convert.ToInt32(Math.Round(ms * OutputConstants.NewLinePauseMultiplier * OutputConstants.DefaultDebugTypeSpeedModifier)));
#else
            await Task.Delay(ms * OutputConstants.NewLinePauseMultiplier);
#endif
        }
        isTypingDialogue = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task<int> GetDialogueChoice(int choiceCount)
    {
        choiceCompletionSource = new TaskCompletionSource<int>();
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);

        // Wait for output queue to be fully processed so choices are visible
        if (Instance != null)
            await Instance.FlushOutputQueueAsync();

        // If a silent path is set, start the timeout logic
        if (!string.IsNullOrWhiteSpace(GameContext.InkRunner.CurrentSilentPath))
        {
            var timeoutTask = Task.Delay(GameContext.InkRunner.SilentPathWait);
            var choiceTask = choiceCompletionSource.Task;
            var completedTask = await Task.WhenAny(choiceTask, timeoutTask);

            if (completedTask == timeoutTask)
            {
                await GameContext.InkRunner.TryJumpToSilentPathAsync();
                // Return early so we do NOT await choiceCompletionSource.Task
                return -1; // or some sentinel value
            }
        }

        // If no silent path, or if the user made a choice in time, just wait for the choice
        int choice = await choiceCompletionSource.Task;
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);
        return choice;
    }

    private async Task SelectDialogueChoice(int choice)
    {
        choiceCompletionSource?.TrySetResult(choice);
    }

    private async Task<string> GetPlayerInputFromUIAsync(bool isDialogue)
    {
        playerInputTcs = new TaskCompletionSource<string>();
        isAwaitingPlayerInput = true;
        isDialogueInput = isDialogue;
        await InvokeAsync(StateHasChanged);
        return await playerInputTcs.Task;
    }

    private async Task HandleInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(userInput))
        {
            if (isAwaitingPlayerInput && playerInputTcs != null)
            {
                playerInputTcs.TrySetResult(userInput);
                isAwaitingPlayerInput = false;
                userInput = "";
                await InvokeAsync(StateHasChanged);
                return;
            }
            try
            {
                EnqueueOutput($"> {userInput}");
                string command = userInput.Trim();
                EnqueueOutput($"[DEBUG] Executing command: '{command}'");
                EnqueueOutput($"[DEBUG] Player location: {GameContext.Player.CurrentLocation.Name}");
                EnqueueOutput($"[DEBUG] Player sublocation: {(GameContext.Player.CurrentSublocation?.Name.ReferenceName ?? "None")}");
                EnqueueOutput($"[DEBUG] Sublocation object: {(GameContext.Player.CurrentSublocation?.GameObject?.GetType().Name ?? "None")}");
                engine.ReceiveCommand(command);
                EnqueueOutput($"[DEBUG] Command execution completed");
            }
            catch (Exception ex)
            {
                EnqueueOutput($"[ERROR] Command execution failed: {ex.Message}");
                EnqueueOutput($"[ERROR] Stack trace: {ex.StackTrace}");
            }
            finally
            {
                userInput = "";
            }
        }
    }

    private async Task AutoScrollToBottom()
    {
        try
        {
            if (JS != null)
            {
                await JS.InvokeVoidAsync("scrollGameOutputToBottom", false); // false = instant
                await Task.Delay(10);
            }
        }
        catch (Exception ex)
        {
            gameText += $"\n[ERROR] JS interop failed: {ex.Message}\n";
            await InvokeAsync(StateHasChanged);
        }
    }
}
