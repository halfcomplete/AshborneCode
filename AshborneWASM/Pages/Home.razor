@using AshborneGame._Core.Game
@using AshborneGame._Core.SceneManagement;
@using AshborneGame._Core.Globals.Constants
@using AshborneGame._Core.Globals.Services
@using System.Diagnostics;
@using System.Text;
@using AshborneGame.WebPort
@using Microsoft.JSInterop
@using System.Timers
@page "/"
@inject IJSRuntime JS

<div class="main-container game-bg-black">
    <div class="game-content">
        <div class="scene-header">
            @if (GameContext.Player?.CurrentScene != null && GameContext.GameState != null)
            {
                int actNo = 1;
                GameContext.GameState.TryGetCounter(GameStateKeyConstants.Counters.Player.CurrentActNo, out actNo);
                string actLabel = "PART " + IntToRomanConversionService.IntToRoman(actNo);
                var scene = GameContext.Player.CurrentScene;
                int sceneNo = 1;
                GameContext.GameState.TryGetCounter(GameStateKeyConstants.Counters.Player.CurrentSceneNo, out sceneNo);
                string sceneLabel;
                string final;
                if (sceneNo != 0)
                {
                    sceneLabel = IntToRomanConversionService.IntToRoman(sceneNo);
                    final = $"{actLabel}: CHAPTER {sceneLabel} — {scene.DisplayName.ToUpper()}";
                }
                else
                {
                    sceneLabel = string.Empty;
					final = $"{scene.DisplayName.ToUpper()}";
                }
				
                <span class="scene-header-text">
                    @final
                </span>
            }
        </div>
        <div class="game-screen">
            <div class="game-output">@((MarkupString)RenderGameText(gameText))</div>
@code {
    private string RenderGameText(string text)
    {
        // Replace <i>...</i> with <span class="game-italic">...</span>
        var sb = new System.Text.StringBuilder();
        int idx = 0;
        while (idx < text.Length)
        {
            int start = text.IndexOf(OutputConstants.InlineItalicStartMarker, idx);
            if (start == -1)
            {
                sb.Append(text.Substring(idx).Replace("\n", "<br />"));
                break;
            }
            sb.Append(text.Substring(idx, start - idx).Replace("\n", "<br />"));
            int end = text.IndexOf(OutputConstants.InlineItalicEndMarker, start);
            if (end == -1)
            {
                sb.Append(text.Substring(start).Replace("\n", "<br />"));
                break;
            }
            int contentStart = start + OutputConstants.InlineItalicStartMarker.Length;
            string italicContent = text.Substring(contentStart, end - contentStart);
            sb.Append($"<span class='game-italic'>{System.Net.WebUtility.HtmlEncode(italicContent)}</span>");
            idx = end + OutputConstants.InlineItalicEndMarker.Length;
        }
        return sb.ToString();
    }
}
            <div class="input-gif-overlay-container">
                @if (isAwaitingPlayerInput)
                {
                    <div class="input-overlay-wrapper">
                        <input @bind="userInput"
                               @bind:event="oninput"
                               @onkeydown="HandleInput"
                               placeholder="@playerInputPrompt" autofocus />
                        @if (GameContext.Player.EquippedItems["face"]?.Name == "Ossaneth")
                        {
                            @if (isOssanethGifActive)
                            {
                                <img src="/visual/mask-sigils/ossaneth-blinking-eye-sigil/ossaneth-blinking-eye-sigil.gif" class="input-overlay-gif @(ShouldGifFadeOut ? "fade-out" : "fade-in")" alt="Ossaneth Blinking Eye Sigil" />
                            }
                            else
                            {
                                <img src="/visual/mask-sigils/ossaneth-blinking-eye-sigil/ossaneth-blinking-eye-sigil.png" class="input-overlay-gif @(ShouldGifFadeOut ? "fade-out" : "fade-in")" alt="Ossaneth Blinking Eye Sigil" />
                            }
                        }
                    </div>
                    <div><em>Type your response and press Enter.</em></div>
                }
                else if (isInDialogue && dialogueChoices.Count > 0 && !isTypingDialogue)
                {
                    <div class="dialogue-choices" style="position: relative;">
                        @if (silentTimerActive && silentTimerSecondsLeft <= 10)
                        {
                            <div class="silent-timer">
                                @silentTimerSecondsLeft
                            </div>
                        }
                        <p>Choose an option:</p>
                        @for (int i = 0; i < dialogueChoices.Count; i++)
                        {
                            int choiceIndex = i; // Capture the index for the lambda
                            <button @onclick="() => SelectDialogueChoice(choiceIndex + 1)" class="choice-button">
                                [@(choiceIndex + 1)] @dialogueChoices[i]
                            </button>
                        }
                    </div>
                }
                else if (!isInDialogue)
                {
                    @if (isTypingDialogue)
                    {
                        <div class="dialogue-waiting">
                            <p>@waitingText</p>
                        </div>
                    }
                    else
                    {
                        <div class="input-overlay-wrapper">
                            <input @bind="userInput"
                                   @bind:event="oninput"
                                   @onkeydown="HandleInput"
                                   placeholder="What will you do?" />
                            @if (GameContext.Player.EquippedItems["face"]?.Name == "Ossaneth")
                            {
                                @if (isOssanethGifActive)
                                {
                                    <img src="/visual/mask-sigils/ossaneth-blinking-eye-sigil/ossaneth-blinking-eye-sigil.gif" class="input-overlay-gif @(ShouldGifFadeOut ? "fade-out" : "fade-in")" alt="Ossaneth Blinking Eye Sigil" />
                                }
                                else
                                {
                                    <img src="/visual/mask-sigils/ossaneth-blinking-eye-sigil/ossaneth-blinking-eye-sigil.png" class="input-overlay-gif @(ShouldGifFadeOut ? "fade-out" : "fade-in")" alt="Ossaneth Blinking Eye Sigil" />
                                }
                            }
                        </div>
                        <div><em>Type your action and press Enter.</em></div>
                    }
                }
                else
                {
                    <div class="dialogue-waiting">
                        <p>@listeningText</p>
                    </div>
                }
            </div>
        </div>
    </div>
    @if (!hasStarted || isFading)
    {
        <div class="title-screen @(isFading ? "fade-out" : "") @(isIntroTransitioning ? "fade-overlap" : "")">
            <div class="title-logo">ASHBORNE</div>
            <button class="begin-button" @onclick="BeginGame">Begin</button>
        </div>
    }
    @if (introPhase > 0 || isIntroTransitioning)
    {
        <div class="intro-screen @(introFading ? "fade-out" : "fade-in")">
            <div class="intro-text @(introTextFading ? "fade-out" : "fade-in") @(isFinalPhase ? "final-phase" : "")">@introText</div>
        </div>
    }
</div>

@* <div>
    <pre>
        isInDialogue: @isInDialogue
        isAwaitingPlayerInput: @isAwaitingPlayerInput
        dialogueChoices.Count: @dialogueChoices.Count
        isTypingDialogue: @isTypingDialogue
    </pre>
</div> *@

@code {
    [Inject] private HttpClient? Http { get; set; }
    [Inject] private NavigationManager? Navigation { get; set; }
    [Inject] private AppEnvironment? AppEnv { get; set; }
    private string userInput = "";
    private string gameText = "";
    private GameEngine engine;
    private bool _isInDialogue = true;
    private bool isInDialogue
    {
        get => _isInDialogue;
        set
        {
            if (_isInDialogue != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                var stack = Environment.StackTrace;
                Console.WriteLine($"[DEBUG] isInDialogue changed from {_isInDialogue} to {value} at {DateTime.Now} | canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _isInDialogue = value;
        }
    }

    private bool _isTypingDialogue = false;
    private bool isTypingDialogue
    {
        get => _isTypingDialogue;
        set
        {
            if (_isTypingDialogue != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                // var stack = Environment.StackTrace;
                var stack = string.Empty;
                Console.WriteLine($"[DEBUG] isTypingDialogue changed from {_isTypingDialogue} to {value} at {DateTime.Now} | canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _isTypingDialogue = value;
        }
    }

    private List<string> _dialogueChoices = new List<string>();
    private List<string> dialogueChoices
    {
        get => _dialogueChoices;
        set
        {
            if (_dialogueChoices != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                var stack = Environment.StackTrace;
                Console.WriteLine($"[DEBUG] dialogueChoices changed at {DateTime.Now} | newCount={value?.Count} canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _dialogueChoices = value;
        }
    }
    private TaskCompletionSource<int> choiceCompletionSource;
    private bool _isAwaitingPlayerInput = false;
    private bool isAwaitingPlayerInput
    {
        get => _isAwaitingPlayerInput;
        set
        {
            if (_isAwaitingPlayerInput != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                var stack = Environment.StackTrace;
                Console.WriteLine($"[DEBUG] isAwaitingPlayerInput changed from {_isAwaitingPlayerInput} to {value} at {DateTime.Now} | canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _isAwaitingPlayerInput = value;
        }
    }
    private bool isDialogueInput = false;
    private TaskCompletionSource<string> playerInputTcs;
    private TaskCompletionSource<bool> choicesAvailableTcs;
    private bool hasStarted = false;
    private bool isFading = false;
    private const int FadeDurationMs = 1000;

    // Intro sequence variables
    private int introPhase = 0;
    private string introText = "";
    private bool introFading = false;
    private const int IntroDelayMs = 2000;
    private const int IntroFadeDurationMs = 800;
    private const int Phase1DurationMs = 5000; // 5 seconds for phase 1
    private const int Phase2DurationMs = 3000; // 3 seconds for phase 2
    private const int Phase3DurationMs = 4000; // 4 seconds for phase 3
    private const int FinalPhaseDurationMs = 5000; // 5 seconds for final phase enlargement

    // Output queue for all output (lines, pauses, typewriter)
    private Queue<string> outputQueue = new Queue<string>();
    private bool isProcessingQueue = false;
    private bool pendingDialogueEnd = false;

    public static Home? Instance;

    private string listeningText = "Listening";
    private System.Threading.Timer? listeningTimer;
    private int listeningStep = 0;
    private readonly string[] listeningStates = new[] { "Listening", "Listening.", "Listening..", "Listening..." };
    private const int ListeningInterval = 400; // ms
    private const int ListeningPause = 600; // ms after 'Listening...'
    private bool listeningActive = false;
    private bool prevListeningActive = false;

    private string waitingText = "Waiting";
    private System.Threading.Timer? waitingTimer;
    private int waitingStep = 0;
    private readonly string[] waitingStates = new[] { "Waiting", "Waiting.", "Waiting..", "Waiting..." };
    private bool waitingActive = false;
    private bool prevWaitingActive = false;

    private bool silentTimerActive = false;
    private int silentTimerSecondsLeft = 0;
    private DateTime silentTimerEndTime;
    private System.Timers.Timer? silentTimer;

    private bool isOssanethGifActive = false;
    private System.Threading.Timer? ossanethSigilTimer;
    private readonly Random ossanethRandom = new Random();
    private const int OssanethGifDurationMs = 633;
    private const int OssanethMinDelayMs = 3000;
    private const int OssanethMaxDelayMs = 8000;

    private bool isIntroTransitioning = false;
    private bool introTextFading = false;
    private bool isFinalPhase = false;

    private void StartListeningAnimation()
    {
        listeningStep = 0;
        listeningText = listeningStates[0];
        listeningTimer?.Dispose();
        listeningTimer = new System.Threading.Timer(_ =>
        {
            listeningStep = (listeningStep + 1) % listeningStates.Length;
            listeningText = listeningStates[listeningStep];
            InvokeAsync(StateHasChanged);
            if (listeningStep == 0)
            {
                listeningTimer?.Change(ListeningPause, ListeningInterval);
            }
            else if (listeningStep == listeningStates.Length - 1)
            {
                listeningTimer?.Change(ListeningPause, (ListeningInterval + ListeningPause) / 2);
            }
            else
            {
                listeningTimer?.Change(ListeningInterval, ListeningInterval);
            }
        }, null, ListeningInterval, ListeningInterval);
    }

    private void StopListeningAnimation()
    {
        listeningTimer?.Dispose();
        listeningTimer = null;
        listeningText = listeningStates[0];
    }

    private void StartWaitingAnimation()
    {
        waitingStep = 0;
        waitingText = waitingStates[0];
        waitingTimer?.Dispose();
        waitingTimer = new System.Threading.Timer(_ =>
        {
            waitingStep = (waitingStep + 1) % waitingStates.Length;
            waitingText = waitingStates[waitingStep];
            InvokeAsync(StateHasChanged);
            if (waitingStep == 0)
            {
                waitingTimer?.Change(ListeningPause, ListeningInterval);
            }
            else if (waitingStep == waitingStates.Length - 1)
            {
                waitingTimer?.Change(ListeningPause, (ListeningInterval + ListeningPause) / 2);
            }
            else
            {
                waitingTimer?.Change(ListeningInterval, ListeningInterval);
            }
        }, null, ListeningInterval, ListeningInterval);
    }

    private void StopWaitingAnimation()
    {
        waitingTimer?.Dispose();
        waitingTimer = null;
        waitingText = waitingStates[0];
    }

    private void StartSilentTimerUI(int ms)
    {
        silentTimerActive = true;
        silentTimerEndTime = DateTime.UtcNow.AddMilliseconds(ms);
        UpdateSilentTimerUI();
        silentTimer?.Dispose();
        silentTimer = new System.Timers.Timer(1000);
        silentTimer.Elapsed += (s, e) =>
        {
            InvokeAsync(() => UpdateSilentTimerUI());
        };
        silentTimer.Start();
    }

    private void StopSilentTimerUI()
    {
        silentTimerActive = false;
        silentTimerSecondsLeft = 0;
        silentTimer?.Stop();
        silentTimer?.Dispose();
        silentTimer = null;
        InvokeAsync(StateHasChanged);
    }

    private void UpdateSilentTimerUI()
    {
        var remaining = (int)Math.Ceiling((silentTimerEndTime - DateTime.UtcNow).TotalSeconds);
        if (remaining <= 0)
        {
            StopSilentTimerUI();
        }
        else
        {
            silentTimerSecondsLeft = remaining;
            InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnInitialized()
    {
        Instance = this;
        if (AppEnv == null)
        {
            throw new InvalidOperationException("AppEnvironment is not injected.");
        }
#if DEBUG
    var outputHandler = new WebOutputHandler(
    async line => EnqueueOutput(line),
    async () => { gameText = ""; await InvokeAsync(StateHasChanged); },
    async (type, msg) => EnqueueOutput($"[DEBUG - {type}]: {msg}")
    );
#else
        var outputHandler = new WebOutputHandler(
            async line => EnqueueOutput(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); }
        );
#endif

        var inputHandler = new WebInputHandler(
            async (prompt) => await GetPlayerInputFromUIAsync(prompt),
            async (choiceCount) => await GetDialogueChoice(choiceCount)
        );

        engine = new GameEngine(inputHandler, outputHandler, AppEnv);

        // Wire up callbacks for dialogue and player input
        if (GameContext.DialogueService != null)
        {
            // Adapted to match Func<bool, Task<string>> expected by InkRunner/DialogueService
            GameContext.DialogueService.SetPlayerInputCallback(async (useDefaultPrompt) => await GetPlayerInputFromUIAsync(playerInputPrompt));
            @* GameContext.DialogueService.DialogueComplete += async () =>
            {
                // Only set isInDialogue to false if not typewriting
                if (!isTypingDialogue)
                {
                    isInDialogue = false;
                    isAwaitingPlayerInput = false;
                    userInput = "";
                    await InvokeAsync(StateHasChanged);
                }
                // Otherwise, let the typewriter effect finish, then set isInDialogue = false at the end of HandleTypewriterEffect
            }; *@
            GameContext.DialogueService.DialogueStart += async () =>
                                    {
                                        isInDialogue = true;
                                        isAwaitingPlayerInput = false;
                                        userInput = "";
                                        await InvokeAsync(StateHasChanged);
                                    };
        }

        if (GameContext.InkRunner != null)
        {
            GameContext.InkRunner.OnDialogueEnd += () =>
            {
                isInDialogue = false;
                isAwaitingPlayerInput = false;
                userInput = "";
                InvokeAsync(StateHasChanged);
            };
        }

        // Do NOT start the game loop here; it will be started after fade.
        StartOssanethSigilTimer();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Auto-scroll to bottom on initial page load
            await Task.Delay(100); // Small delay to ensure DOM is ready
            await AutoScrollToBottom(force:true);
        }
        // Start/stop listening animation based on correct condition
        listeningActive = isInDialogue && !isAwaitingPlayerInput;
        if (listeningActive != prevListeningActive)
        {
            if (listeningActive)
                StartListeningAnimation();
            else
                StopListeningAnimation();
            prevListeningActive = listeningActive;
        }

        // Start/stop waiting animation when typewriting outside of dialogue
        waitingActive = !isInDialogue && isTypingDialogue;
        if (waitingActive != prevWaitingActive)
        {
            if (waitingActive)
                StartWaitingAnimation();
            else
                StopWaitingAnimation();
            prevWaitingActive = waitingActive;
        }
    }

    private void ResetInput()
    {
        isAwaitingPlayerInput = false;
        userInput = "";
        isDialogueInput = false;
        InvokeAsync(StateHasChanged);
    }

    // Enqueue output for sequential processing
    private void EnqueueOutput(string line)
    {
#if DEBUG
        Console.WriteLine($"[DEBUG] EnqueueOutput: {line}");
#endif
        outputQueue.Enqueue(line);
        if (!isProcessingQueue)
        {
            _ = ProcessOutputQueue();
        }
    }

    /// <summary>
    /// Waits until the output queue is fully processed. Used to synchronize output and input.
    /// </summary>
    public async Task FlushOutputQueueAsync()
    {
        // Wait until the output queue is empty and not processing
        while (outputQueue.Count > 0 || isProcessingQueue)
        {
            await Task.Delay(1);
        }
    }

    private async Task ProcessOutputQueue()
    {
        isProcessingQueue = true;
        while (outputQueue.Count > 0)
        {
            var line = outputQueue.Dequeue();
            if (line == "__END__")
            {
                pendingDialogueEnd = true;
                continue;
            }
            if (line.Contains("__NL__"))
            {
                dialogueChoices.Clear();
                // Handle new line marker
                gameText += "\n";
                continue; // Do not add another new line after this
            }
#if DEBUG
            Console.WriteLine($"[DEBUG] ProcessOutputQueue: {line}");
#endif
            // Handle special pause marker: ms__PAUSE__
            if (line.TrimEnd().EndsWith(OutputConstants.DialoguePauseMarker))
            {
                dialogueChoices.Clear();
                var msStr = line.Substring(0, line.IndexOf(OutputConstants.DialoguePauseMarker));
                if (int.TryParse(msStr, out int ms))
                {
                    await InvokeAsync(StateHasChanged);
                    await Task.Yield();
                    #if DEBUG
                    await Task.Delay(Convert.ToInt32(Math.Round(ms * OutputConstants.DefaultDebugTypeSpeedModifier)));
                    #else
                    await Task.Delay(ms);
                    #endif
                }
                else
                {
                    await InvokeAsync(StateHasChanged);
                    await Task.Yield();
                    await Task.Delay(OutputConstants.DefaultPauseDuration);
                }
                continue; // Do not add pause marker to output buffer
            }

            // Handle new line marker
            if (line.Equals(OutputConstants.NewLineMarker))
            {
                Console.WriteLine($"[DEBUG] Detected new line marker in line: {line}");
                gameText += "\n";
                await InvokeAsync(StateHasChanged);
                await AutoScrollToBottom();
                await Task.Delay(OutputConstants.DefaultTypeSpeed * OutputConstants.NewLinePauseMultiplier);
                continue; // Do not add new line marker to output buffer
            }

            // Handle typewriter effect
            if (line.Contains(OutputConstants.TypewriterStartMarker) && line.Contains(OutputConstants.TypewriterEndMarker))
            {
                dialogueChoices.Clear();
                await HandleTypewriterEffect(line);
                continue;
            }

            // Dialogue choice line
            if (line.Trim().StartsWith("[") && line.Contains("]") && line.Trim().Length > 2)
            {
                Console.WriteLine($"[DEBUG] Detected dialogue choice in line: {line}");
                int bracketEnd = line.IndexOf("]");
                if (bracketEnd > 0 && int.TryParse(line.Substring(1, bracketEnd - 1), out int choiceNumber))
                {
                    if (GameContext.InkRunner != null && GameContext.InkRunner.Story != null &&
                        GameContext.InkRunner.Story.currentChoices != null && choiceNumber > 0 && 
                        choiceNumber == GameContext.InkRunner.Story.currentChoices.Count)
                    {
						// We are currently processing the last choice, so start the silent timer
                        await GameContext.InkRunner.StartSilentTimer();
                        // Start UI timer if silent path is set and > 0
                        if (!string.IsNullOrWhiteSpace(GameContext.InkRunner.CurrentSilentPath) && GameContext.InkRunner.SilentPathWait > 0)
                        {
                            StartSilentTimerUI(GameContext.InkRunner.SilentPathWait);
                        }
                        else
                        {
                            StopSilentTimerUI();
                        }
                    }

                    string choiceText = line.Substring(bracketEnd + 1).Trim();
                    if (!string.IsNullOrWhiteSpace(choiceText))
                    {
                        dialogueChoices.Add(choiceText);
                        await InvokeAsync(StateHasChanged);
                        await AutoScrollToBottom();
                        continue;
                    }
                }
            }

            // Normal line
            if (!string.IsNullOrWhiteSpace(line))
            {
                gameText += line + "\n";
            }
            else
            {
                gameText += "\n";
            }
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();
        }
        isProcessingQueue = false;

        // After all output is processed and typewriter is done
        if (pendingDialogueEnd && !isTypingDialogue)
        {
            Console.WriteLine($"[DEBUG] ProcessOutputQueue: Flushed output, ending dialogue at {DateTime.Now}");
            isInDialogue = false;
            isAwaitingPlayerInput = false;
            userInput = "";
            pendingDialogueEnd = false;
            GameContext.InkRunner?.DialogueFinishedOutputting();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleTypewriterEffect(string line)
    {
        // Parse ms value at the start of the line (e.g. "50__TS__...")
        int ms = OutputConstants.DefaultTypeSpeed; // default
        Console.WriteLine($"[DEBUG] Handling typewriter effect for line: {line}");
        int msEnd = line.IndexOf(OutputConstants.TypewriterStartMarker);
        if (msEnd > 0)
        {
            string msStr = line.Substring(0, msEnd);
            if (!int.TryParse(msStr, out ms)) ms = OutputConstants.DefaultTypeSpeed;
        }
        Console.WriteLine($"[DEBUG] Typewriter effect with delay: {ms} ms");
        int startIndex = line.IndexOf(OutputConstants.TypewriterStartMarker) + OutputConstants.TypewriterStartMarker.Length;
        int endIndex = line.IndexOf(OutputConstants.TypewriterEndMarker);
        string message = line.Substring(startIndex, endIndex - startIndex);
		    Console.WriteLine($"[DEBUG] Typewriter message: {message}");

        // Process inline slow markers in the message BEFORE starting typewriter effect
        var (processedMessage, characterSpeeds) = ProcessInlineSlowMarkersWithSpeeds(message, ms);

        isTypingDialogue = true;
        Console.WriteLine($"[DEBUG] isTypingDialogue set to true for message: {message}");
        await InvokeAsync(StateHasChanged);
        Console.WriteLine($"[DEBUG] InvokeAsync called after setting isTypingDialogue");

        // Split into lines and type each line separately
        string[] lines = processedMessage.Split('\n');
        var buffer = gameText.Split('\n').ToList(); // Keep previous lines
        int globalCharIndex = 0; // Track character position across all lines

        foreach (var msgLine in lines)
        {
			      Console.WriteLine($"[DEBUG] Typing line: {msgLine}");
            string typedLine = "";
            bool inItalic = false;
            for (int i = 0; i < msgLine.Length; i++)
            {
                // Check for start/end italic markers
                if (msgLine.Substring(i).StartsWith(OutputConstants.InlineItalicStartMarker))
                {
                    inItalic = true;
                    i += OutputConstants.InlineItalicStartMarker.Length - 1;
                    continue;
                }
                if (msgLine.Substring(i).StartsWith(OutputConstants.InlineItalicEndMarker))
                {
                    inItalic = false;
                    i += OutputConstants.InlineItalicEndMarker.Length - 1;
                    continue;
                }

                char letter = msgLine[i];
                string charToAdd = inItalic ? $"<span class='game-italic'>{System.Net.WebUtility.HtmlEncode(letter.ToString())}</span>" : System.Net.WebUtility.HtmlEncode(letter.ToString());
                typedLine += charToAdd;
                gameText = string.Join('\n', buffer) + (buffer.Count > 0 ? "\n" : "") + typedLine;
                await InvokeAsync(StateHasChanged);
                await AutoScrollToBottom();

                // Calculate isEnd using the same logic as Console version
                bool isEnd = i == msgLine.Length - 1 || 
                            (i + 1 < msgLine.Length && msgLine[i + 1].Equals(' ')) || 
                            (i + 1 < msgLine.Length && msgLine[i + 1].Equals('\n'));

                // Get the speed for this character (if available)
                int currentSpeed = ms;
                if (characterSpeeds != null && characterSpeeds.Count > globalCharIndex)
                {
                    currentSpeed = characterSpeeds[globalCharIndex];
                }

                // Calculate delay with special handling for non-dialogue output
                int delay;
                int baseDelay;
#if DEBUG
                baseDelay = await CharacterOutputDelayCalculator.CalculateDebugDelayAsync(letter, currentSpeed, isEnd);
#else
                baseDelay = await CharacterOutputDelayCalculator.CalculateDelayAsync(letter, currentSpeed, isEnd);
#endif
                bool isDialogueOutput = (ms == OutputConstants.DefaultTypeSpeed);
                if (!isDialogueOutput)
                {
                    bool isPunctuation = letter == '.' || letter == '—' || letter == ',' || letter == '"' || letter == ':' || letter == ']' || letter == ')';
                    if (isPunctuation)
                    {
                        delay = baseDelay;
                    }
                    else
                    {
                        delay = (int)(baseDelay * OutputConstants.NonDialogueOutputSpeedMultiplier);
                    }
                }
                else
                {
                    delay = baseDelay;
                }
                await Task.Delay(delay);
                globalCharIndex++;
            }
            buffer.Add(typedLine);
            gameText = string.Join('\n', buffer);
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();
#if DEBUG
            await Task.Delay(Convert.ToInt32(Math.Round(ms * OutputConstants.NewLinePauseMultiplier * OutputConstants.DefaultDebugTypeSpeedModifier)));
#else
            await Task.Delay(ms * OutputConstants.NewLinePauseMultiplier);
#endif
        }
		Console.WriteLine($"[DEBUG] Finished typing dialogue: {message}");
        isTypingDialogue = false;
        await InvokeAsync(StateHasChanged);

        // After typewriter effect, if pendingDialogueEnd is set and output queue is empty, end dialogue
        if (pendingDialogueEnd && !isProcessingQueue)
        {
            Console.WriteLine($"[DEBUG] HandleTypewriterEffect: Flushed output, ending dialogue at {DateTime.Now}");
            isInDialogue = false;
            isAwaitingPlayerInput = false;
            userInput = "";
            pendingDialogueEnd = false;
            GameContext.InkRunner?.DialogueFinishedOutputting();
            await InvokeAsync(StateHasChanged);
        }
    }

    private (string processedMessage, List<int> characterSpeeds) ProcessInlineSlowMarkersWithSpeeds(string message, int defaultMs)
    {
        var processedMessage = new StringBuilder();
        var characterSpeeds = new List<int>();
        int currentIndex = 0;

        while (currentIndex < message.Length)
        {
            // 1) find the next “__IS__”
            int inlineStartIndex = message.IndexOf(
                OutputConstants.InlineTypewriterStartMarker,
                currentIndex);
            if (inlineStartIndex == -1)
            {
                // no more markers → dump the rest
                var tail = message.Substring(currentIndex);
                processedMessage.Append(tail);
                characterSpeeds.AddRange(
                    Enumerable.Repeat(defaultMs, tail.Length));
                break;
            }

            // 2) scan backwards from inlineStartIndex to grab any digits
            int speedStartIndex = inlineStartIndex;
            while (speedStartIndex > currentIndex
                   && char.IsDigit(message[speedStartIndex - 1]))
                speedStartIndex--;

            // 3) everything between currentIndex and speedStartIndex is “beforeText”
            var beforeText = message.Substring(
                currentIndex,
                speedStartIndex - currentIndex);
            processedMessage.Append(beforeText);
            characterSpeeds.AddRange(
                Enumerable.Repeat(defaultMs, beforeText.Length));

            // 4) parse the speed override (if any)
            int inlineSpeed = defaultMs;
            if (speedStartIndex < inlineStartIndex)
            {
                var speedStr = message.Substring(
                    speedStartIndex,
                    inlineStartIndex - speedStartIndex);
                if (int.TryParse(speedStr, out var parsed))
                    inlineSpeed = parsed;
            }

            // 5) find the matching end‐marker
            int inlineEndIndex = message.IndexOf(
                OutputConstants.InlineTypewriterEndMarker,
                inlineStartIndex);
            if (inlineEndIndex == -1)
            {
                // unmatched → treat rest as normal text
                var tail = message.Substring(inlineStartIndex);
                processedMessage.Append(tail);
                characterSpeeds.AddRange(
                    Enumerable.Repeat(defaultMs, tail.Length));
                break;
            }

            // 6) extract the text *inside* the markers
            int inlineTextStart = inlineStartIndex
                                  + OutputConstants
                                     .InlineTypewriterStartMarker.Length;
            var inlineText = message.Substring(
                inlineTextStart,
                inlineEndIndex - inlineTextStart);

            processedMessage.Append(inlineText);
            characterSpeeds.AddRange(
                Enumerable.Repeat(inlineSpeed, inlineText.Length));

            // 7) advance past the end‐marker
            currentIndex = inlineEndIndex
                           + OutputConstants
                             .InlineTypewriterEndMarker.Length;
        }

        return (processedMessage.ToString(), characterSpeeds);
    }


    private async Task<int> GetDialogueChoice(int choiceCount)
    {
        Console.WriteLine($"[DEBUG] GetDialogueChoice called with count={choiceCount} at {DateTime.Now}, isInDialogue={isInDialogue}");
        choiceCompletionSource = new TaskCompletionSource<int>();
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);

        // Wait for output queue to be fully processed so choices are visible
        if (Instance != null)
            await Instance.FlushOutputQueueAsync();

        int choice = await choiceCompletionSource.Task;
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);

        // Defensive: If the story is finished after the choice, do not return a choice
        if (GameContext.InkRunner == null || 
            (GameContext.InkRunner.Story != null && 
             !GameContext.InkRunner.Story.canContinue && 
             (GameContext.InkRunner.Story.currentChoices == null || GameContext.InkRunner.Story.currentChoices.Count == 0)))
        {
            Console.WriteLine("[DEBUG] GetDialogueChoice: Story is finished after waiting, not returning a choice.");
            return -1;
        }

        return choice;
    }

    private async Task SelectDialogueChoice(int choice)
    {
        StopSilentTimerUI();
        choiceCompletionSource?.TrySetResult(choice);
    }

    private string playerInputPrompt = "What will you say?";
    private async Task<string> GetPlayerInputFromUIAsync(string prompt)
    {
        playerInputTcs = new TaskCompletionSource<string>();
        isAwaitingPlayerInput = true;
        isDialogueInput = true;
        playerInputPrompt = string.IsNullOrWhiteSpace(prompt) ? "What will you say?" : prompt;
        await InvokeAsync(StateHasChanged);
        var input = await playerInputTcs.Task;
        playerInputPrompt = "What will you say?";
        return input;
    }

    private async Task HandleInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(userInput))
        {
            if (isAwaitingPlayerInput && playerInputTcs != null)
            {
                playerInputTcs.TrySetResult(userInput);
                isAwaitingPlayerInput = false;
                userInput = "";
                await InvokeAsync(StateHasChanged);
                return;
            }
            try
            {
                EnqueueOutput($"> {userInput}");
                string command = userInput.Trim();
                #if DEBUG
                EnqueueOutput($"[DEBUG] Executing command: '{command}'");
                EnqueueOutput($"[DEBUG] Player location: {GameContext.Player.CurrentLocation.Name}");
                EnqueueOutput($"[DEBUG] Player sublocation: {(GameContext.Player.CurrentSublocation?.Name.ReferenceName ?? "None")}");
                EnqueueOutput($"[DEBUG] Sublocation object: {(GameContext.Player.CurrentSublocation?.FocusObject?.GetType().Name ?? "None")}");
                #endif
                engine.ReceiveCommand(command);
                #if DEBUG
                EnqueueOutput($"[DEBUG] Command execution completed");
                #endif
            }
            catch (Exception ex)
            {
                #if DEBUG
                EnqueueOutput($"[ERROR] Command execution failed: {ex.Message}");
                EnqueueOutput($"[ERROR] Stack trace: {ex.StackTrace}");
                #endif
            }
            finally
            {
                userInput = "";
            }
        }
    }

    private async Task AutoScrollToBottom(bool force = false)
    {
        try
        {
            if (JS != null)
            {
                await JS.InvokeVoidAsync("scrollGameOutputToBottom", force);
                await Task.Delay(10);
            }
        }
        catch (Exception ex)
        {
            gameText += $"\n[ERROR] JS interop failed: {ex.Message}\n";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async void BeginGame()
    {
        isIntroTransitioning = true;
        isFading = true;
        StateHasChanged();
        await Task.Delay(FadeDurationMs); // Let title screen fully fade out
        hasStarted = true;
        isFading = false;
        StateHasChanged();
        await Task.Delay(2000); // 2 second pause with just background
        isIntroTransitioning = false;
        StateHasChanged();
        introPhase = 1;
        introText = "All the world's a stage, and all the men and women merely players.";
        introFading = false;
        introTextFading = true; // Start with text faded out
        StateHasChanged();
        await Task.Delay(50); // Brief delay to ensure fade-in animation triggers
        introTextFading = false; // Trigger fade-in
        StateHasChanged();
        await StartIntroSequence();
        engine.StartGameLoopAsync();
        StateHasChanged();
    }

    private async Task StartIntroSequence()
    {
        // Phase 1 already set by BeginGame
        await Task.Delay(Phase1DurationMs);
        // Phase 2
        introTextFading = true;
        StateHasChanged();
        await Task.Delay(IntroFadeDurationMs);
        introText = "But who wrote the script?";
        introTextFading = false;
        StateHasChanged();
        await Task.Delay(Phase2DurationMs);
        // Phase 3
        introTextFading = true;
        StateHasChanged();
        await Task.Delay(IntroFadeDurationMs);
        introText = "And who dares rewrite it?";
        introTextFading = false;
        StateHasChanged();
        await Task.Delay(Phase3DurationMs);
        // Final Phase: ASHBORNE
        introTextFading = true;
        StateHasChanged();
        await Task.Delay(IntroFadeDurationMs);
        introText = "ASHBORNE";
        introTextFading = false;
        isFinalPhase = true;
        StateHasChanged();
        await Task.Delay(FinalPhaseDurationMs);
        // Fade out intro and start game
        introFading = true;
        StateHasChanged();
        await Task.Delay(IntroFadeDurationMs);
        introPhase = 0;
        isFinalPhase = false;
        StateHasChanged();
    }

    private bool ShouldGifFadeOut => isInDialogue && dialogueChoices.Count > 0 && !isTypingDialogue;

    private void StartOssanethSigilTimer()
    {
        if (GameContext.Player.EquippedItems["face"]?.Name != "Ossaneth")
        {
            isOssanethGifActive = false;
            ossanethSigilTimer?.Dispose();
            return;
        }
        int delay = ossanethRandom.Next(OssanethMinDelayMs, OssanethMaxDelayMs);
        ossanethSigilTimer?.Dispose();
        ossanethSigilTimer = new System.Threading.Timer(_ =>
        {
            if (!isOssanethGifActive)
            {
                isOssanethGifActive = true;
                InvokeAsync(StateHasChanged);
                // Show GIF for its duration, then revert to PNG
                ossanethSigilTimer?.Dispose();
                ossanethSigilTimer = new System.Threading.Timer(__ =>
                {
                    isOssanethGifActive = false;
                    InvokeAsync(StateHasChanged);
                    StartOssanethSigilTimer(); // Schedule next random swap
                }, null, OssanethGifDurationMs, System.Threading.Timeout.Infinite);
            }
        }, null, delay, System.Threading.Timeout.Infinite);
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);
        // Defensive: restart timer if component is re-rendered and mask is equipped
        if (ossanethSigilTimer == null && GameContext.Player.EquippedItems["face"]?.Name == "Ossaneth")
        {
            StartOssanethSigilTimer();
        }
        else if (GameContext.Player.EquippedItems["face"]?.Name != "Ossaneth")
        {
            isOssanethGifActive = false;
            ossanethSigilTimer?.Dispose();
            ossanethSigilTimer = null;
        }
    }

    public void Dispose()
    {
        ossanethSigilTimer?.Dispose();
        listeningTimer?.Dispose();
        waitingTimer?.Dispose();
    }
}
