@using AshborneGame._Core.Game
@using AshborneGame._Core.Globals.Services
@using AshborneGame.WebPort
@using Microsoft.JSInterop
@page "/"
@inject IJSRuntime JS

<h1 class="text-center">ASHBORNE</h1>

<div class="game-screen">
    <div class="game-output">@gameText</div>

    @if (isAwaitingPlayerInput)
    {
        <input @bind="userInput"
               @bind:event="oninput"
               @onkeydown="HandleInput"
               placeholder="@(isDialogueInput ? "What do you say?" : "What will you do?")" autofocus />
        <div><em>Type your response and press Enter.</em></div>
    }
    else if (isInDialogue && dialogueChoices.Count > 0 && !isTypingDialogue)
    {
        <div class="dialogue-choices">
            <p>Choose an option:</p>
            @for (int i = 0; i < dialogueChoices.Count; i++)
            {
                int choiceIndex = i; // Capture the index for the lambda
                                     <button @onclick="() => SelectDialogueChoice(choiceIndex + 1)" class="choice-button">
                                         [@(choiceIndex + 1)] @dialogueChoices[i]
                                     </button>
            }
        </div>
    }
    else if (!isInDialogue)
    {
        <input @bind="userInput"
               @bind:event="oninput"
               @onkeydown="HandleInput"
               placeholder="What will you do?" />
        <div><em>Type your action and press Enter.</em></div>
    }
    else
    {
        <div class="dialogue-waiting">
            <p>Listening...</p>
        </div>
    }
</div>

@code {
    [Inject] private HttpClient Http { get; set; }
    [Inject] private NavigationManager Navigation { get; set; }
    [Inject] private AppEnvironment AppEnv { get; set; }
    private string userInput = "";
    private string gameText = "";
    private GameEngine engine;
    private bool isInDialogue = false;
    private bool isTypingDialogue = false;
    private List<string> dialogueChoices = new List<string>();
    private TaskCompletionSource<int> choiceCompletionSource;
    private Queue<string> typewriterQueue = new Queue<string>();
    private bool isTypewriterRunning = false;
    private bool isAwaitingPlayerInput = false;
    private bool isDialogueInput = false;
    private TaskCompletionSource<string> playerInputTcs;

    protected override void OnInitialized()
    {
#if DEBUG
        var outputHandler = new WebOutputHandler(
            async line => await AppendLine(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); },
            async (type, msg) => await AppendLine($"[DEBUG - {type}]: {msg}")
        );
#else
        var outputHandler = new WebOutputHandler(
            async line => await AppendLine(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); }
        );
#endif

        var inputHandler = new WebInputHandler(
            async () => await Task.FromResult(userInput),
            async (choiceCount) => await GetDialogueChoice(choiceCount)
        );

        engine = new GameEngine(inputHandler, outputHandler, AppEnv);

		// Wire up callbacks for dialogue and player input
        if (GameContext.DialogueService != null)
        {
            GameContext.DialogueService.SetPlayerInputCallback(GetPlayerInputFromUIAsync);
            GameContext.DialogueService.DialogueComplete += async () =>
            {
                isInDialogue = false;
                isAwaitingPlayerInput = false;
                userInput = "";
                IOService.Output.DisplayDebugMessage($"[DEBUG] DialogueComplete handler called at {DateTime.Now}");
                await InvokeAsync(StateHasChanged);
            };
            GameContext.DialogueService.DialogueStart += async () =>
            {
                isInDialogue = true;
                isAwaitingPlayerInput = false;
                userInput = "";
                IOService.Output.DisplayDebugMessage($"[DEBUG] DialogueStart handler called at {DateTime.Now}");
                await InvokeAsync(StateHasChanged);
            };
        }

        // Start the game without the blocking loop
        engine.StartGameLoopAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Auto-scroll to bottom on initial page load
            await Task.Delay(100); // Small delay to ensure DOM is ready
            await AutoScrollToBottom();
        }
    }

    private void ResetInput()
    {
        isAwaitingPlayerInput = false;
        userInput = "";
        isDialogueInput = false;
        InvokeAsync(StateHasChanged);
    }

    private async Task<int> GetDialogueChoice(int choiceCount)
    {
        // Create a completion source for this choice
        choiceCompletionSource = new TaskCompletionSource<int>();

        dialogueChoices.Clear(); // Clear any existing choices
        await InvokeAsync(StateHasChanged);

        // Wait for choices to be populated (with longer timeout)
        int timeout = 0;
        while (dialogueChoices.Count == 0 && timeout < 5000) // 50 second timeout (5000 * 10ms)
        {
            await Task.Delay(10);
            timeout++;
        }

        if (dialogueChoices.Count == 0)
        {
            // If no choices were detected after timeout, log and wait for user input anyway
            await AppendLine("[DEBUG] No dialogue choices detected after timeout, waiting for manual input");
            await InvokeAsync(StateHasChanged);
            return 1;
        }

        // Wait for the user to make a choice
        int choice = await choiceCompletionSource.Task;

        // Clear dialogue state
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);

        return choice;
    }

    private async Task SelectDialogueChoice(int choice)
    {
        choiceCompletionSource?.TrySetResult(choice);
    }

    private async Task AppendLine(string line)
    {
        // Check if this is a dialogue choice line (format: [1] Choice text)
        // Make sure it's a complete choice line, not just a partial one
        if (line.Trim().StartsWith("[") && line.Contains("]") && line.Trim().Length > 2)
        {
            int bracketEnd = line.IndexOf("]");
            if (bracketEnd > 0 && int.TryParse(line.Substring(1, bracketEnd - 1), out int choiceNumber))
            {
                string choiceText = line.Substring(bracketEnd + 1).Trim();
                if (!string.IsNullOrWhiteSpace(choiceText))
                {
                    await AppendLine($"[DEBUG] Detected dialogue choice {choiceNumber}: {choiceText}");
                    dialogueChoices.Add(choiceText);
                    // Don't immediately show choices - wait for dialogue to complete
                    await InvokeAsync(StateHasChanged);
                    await AutoScrollToBottom();
                    return;
                }
            }
        }

        // Check if this is a typewriter effect message
        if (line.Contains("__TYPEWRITER_START__") && line.Contains("__TYPEWRITER_END__"))
        {
            typewriterQueue.Enqueue(line);
            if (!isTypewriterRunning)
            {
                _ = ProcessTypewriterQueue();
            }
        }
        else
        {
            // Don't add empty lines or lines that are just whitespace
            if (!string.IsNullOrWhiteSpace(line))
            {
                gameText += line + "\n";
            }
            else
            {
                gameText += "\n";
            }
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();
        }
    }

    private async Task ProcessTypewriterQueue()
    {
        isTypewriterRunning = true;
        while (typewriterQueue.Count > 0)
        {
            string line = typewriterQueue.Dequeue();
            await HandleTypewriterEffect(line);
        }
        isTypewriterRunning = false;
    }

    private async Task HandleTypewriterEffect(string line)
    {
        int startIndex = line.IndexOf("__TYPEWRITER_START__") + "__TYPEWRITER_START__".Length;
        int endIndex = line.IndexOf("__TYPEWRITER_END__");
        string message = line.Substring(startIndex, endIndex - startIndex);

        isTypingDialogue = true;
        await InvokeAsync(StateHasChanged);

        // Split into lines and type each line separately
        string[] lines = message.Split('\n');
        var buffer = gameText.Split('\n').ToList(); // Keep previous lines

        foreach (var msgLine in lines)
        {
            string typedLine = "";
            for (int i = 0; i < msgLine.Length; i++)
            {
                typedLine += msgLine[i];
                gameText = string.Join('\n', buffer) + (buffer.Count > 0 ? "\n" : "") + typedLine;
                // Update UI every character
                await InvokeAsync(StateHasChanged);
                await AutoScrollToBottom();
                char currentChar = msgLine[i];
                if ((currentChar == '.' || currentChar == ':' || currentChar == '"' || currentChar == ']') &&
                    (i == msgLine.Length - 1 || msgLine[i + 1] == ' '))
                {
                    await Task.Delay(600);
                }
                else
                {
                    await Task.Delay(24);
                }
            }
            buffer.Add(typedLine); // Add finished line to buffer
            gameText = string.Join('\n', buffer);
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();
            await Task.Delay(100);
        }
        await Task.Delay(200);
        isTypingDialogue = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task<string> GetPlayerInputFromUIAsync(bool isDialogue)
    {
        playerInputTcs = new TaskCompletionSource<string>();
        isAwaitingPlayerInput = true;
        isDialogueInput = isDialogue;
        await InvokeAsync(StateHasChanged);
        return await playerInputTcs.Task;
    }

    private async Task HandleInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(userInput))
        {
            if (isAwaitingPlayerInput && playerInputTcs != null)
            {
                playerInputTcs.TrySetResult(userInput);
                isAwaitingPlayerInput = false;
                userInput = "";
                await InvokeAsync(StateHasChanged);
                return;
            }
            try
            {
                await AppendLine($"\n> {userInput}\n");
                string command = userInput.Trim();
                await AppendLine($"[DEBUG] Executing command: '{command}'");
                await AppendLine($"[DEBUG] Player location: {GameContext.Player.CurrentLocation.Name}");
                await AppendLine($"[DEBUG] Player sublocation: {(GameContext.Player.CurrentSublocation?.Name.ReferenceName ?? "None")}");
                await AppendLine($"[DEBUG] Sublocation object: {(GameContext.Player.CurrentSublocation?.GameObject?.GetType().Name ?? "None")}");
                engine.ReceiveCommand(command);
                await AppendLine($"[DEBUG] Command execution completed");
            }
            catch (Exception ex)
            {
                await AppendLine($"[ERROR] Command execution failed: {ex.Message}");
                await AppendLine($"[ERROR] Stack trace: {ex.StackTrace}");
            }
            finally
            {
                userInput = "";
            }
        }
    }

    private async Task AutoScrollToBottom()
    {
        await JS.InvokeVoidAsync("scrollGameOutputToBottom", false); // false = instant
        await Task.Delay(10);
    }
}
