@using AshborneGame._Core.Game
@using AshborneGame._Core.SceneManagement;
@using AshborneGame._Core.Globals.Constants
@using AshborneGame._Core.Globals.Services
@using System.Diagnostics;
@using AshborneGame.WebPort
@using Microsoft.JSInterop
@page "/"
@inject IJSRuntime JS

<div class="main-container game-bg-black">
    <div class="game-content">
        <div class="scene-header">
            @if (GameContext.Player?.CurrentScene != null && GameContext.GameState != null)
            {
                int actNo = 1;
                GameContext.GameState.TryGetCounter(GameStateKeyConstants.Counters.Player.CurrentActNo, out actNo);
                string actLabel = "ACT " + IntToRomanConversionService.IntToRoman(actNo);
                var scene = GameContext.Player.CurrentScene;
                int sceneNo = 1;
                GameContext.GameState.TryGetCounter(GameStateKeyConstants.Counters.Player.CurrentSceneNo, out sceneNo);
                string sceneLabel;
                string final;
                if (sceneNo != 0)
                {
                    sceneLabel = IntToRomanConversionService.IntToRoman(sceneNo);
                    final = $"{actLabel}: SCENE {sceneLabel} — {scene.DisplayName.ToUpper()}";
                }
                else
                {
                    sceneLabel = string.Empty;
					final = $"{scene.DisplayName.ToUpper()}";
                }
				
                <span class="scene-header-text">
                    @final
                </span>
            }
        </div>
        <div class="game-screen">
            <div class="game-output">@((MarkupString)gameText.Replace("\n", "<br />"))</div>
            @if (isAwaitingPlayerInput)
            {
                <input @bind="userInput"
                       @bind:event="oninput"
                       @onkeydown="HandleInput"
                       placeholder="@(isDialogueInput ? "What do you say?" : "What will you do?")" autofocus />
                <div><em>Type your response and press Enter.</em></div>
            }
            else if (isInDialogue && dialogueChoices.Count > 0 && !isTypingDialogue)
            {
                <div class="dialogue-choices">
                    <p>Choose an option:</p>
                    @for (int i = 0; i < dialogueChoices.Count; i++)
                    {
                        int choiceIndex = i; // Capture the index for the lambda
                                             <button @onclick="() => SelectDialogueChoice(choiceIndex + 1)" class="choice-button">
                                                 [@(choiceIndex + 1)] @dialogueChoices[i]
                                             </button>
                    }
                </div>
            }
            else if (!isInDialogue)
            {
                <input @bind="userInput"
                       @bind:event="oninput"
                       @onkeydown="HandleInput"
                       placeholder="What will you do?" />
                <div><em>Type your action and press Enter.</em></div>
            }
            else
            {
                <div class="dialogue-waiting">
                    <p>@listeningText</p>
                </div>
            }
        </div>
    </div>
    @if (!hasStarted || isFading)
    {
        <div class="title-screen @(isFading ? "fade-out" : "")">
            <div class="title-logo">ASHBORNE</div>
            <button class="begin-button" @onclick="BeginGame">Begin</button>
        </div>
    }
</div>

@* div>
    <pre>
        isInDialogue: @isInDialogue
        isAwaitingPlayerInput: @isAwaitingPlayerInput
        dialogueChoices.Count: @dialogueChoices.Count
        isTypingDialogue: @isTypingDialogue
    </pre>
</div> *@

@code {
    [Inject] private HttpClient? Http { get; set; }
    [Inject] private NavigationManager? Navigation { get; set; }
    [Inject] private AppEnvironment? AppEnv { get; set; }
    private string userInput = "";
    private string gameText = "";
    private GameEngine engine;
    private bool _isInDialogue = true;
    private bool isInDialogue
    {
        get => _isInDialogue;
        set
        {
            if (_isInDialogue != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                var stack = Environment.StackTrace;
                Console.WriteLine($"[DEBUG] isInDialogue changed from {_isInDialogue} to {value} at {DateTime.Now} | canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _isInDialogue = value;
        }
    }

    private bool _isTypingDialogue = false;
    private bool isTypingDialogue
    {
        get => _isTypingDialogue;
        set
        {
            if (_isTypingDialogue != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                // var stack = Environment.StackTrace;
                var stack = string.Empty;
                Console.WriteLine($"[DEBUG] isTypingDialogue changed from {_isTypingDialogue} to {value} at {DateTime.Now} | canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _isTypingDialogue = value;
        }
    }

    private List<string> _dialogueChoices = new List<string>();
    private List<string> dialogueChoices
    {
        get => _dialogueChoices;
        set
        {
            if (_dialogueChoices != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                var stack = Environment.StackTrace;
                Console.WriteLine($"[DEBUG] dialogueChoices changed at {DateTime.Now} | newCount={value?.Count} canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _dialogueChoices = value;
        }
    }
    private TaskCompletionSource<int> choiceCompletionSource;
    private bool _isAwaitingPlayerInput = false;
    private bool isAwaitingPlayerInput
    {
        get => _isAwaitingPlayerInput;
        set
        {
            if (_isAwaitingPlayerInput != value)
            {
                var runner = GameContext.InkRunner;
                var canContinue = runner?.Story?.canContinue;
                var currentChoices = runner?.Story?.currentChoices?.Count;
                var stack = Environment.StackTrace;
                Console.WriteLine($"[DEBUG] isAwaitingPlayerInput changed from {_isAwaitingPlayerInput} to {value} at {DateTime.Now} | canContinue={canContinue} currentChoices={currentChoices}\nStack: {stack}");
            }
            _isAwaitingPlayerInput = value;
        }
    }
    private bool isDialogueInput = false;
    private TaskCompletionSource<string> playerInputTcs;
    private TaskCompletionSource<bool> choicesAvailableTcs;
    private bool hasStarted = false;
    private bool isFading = false;
    private const int FadeDurationMs = 1000;

    // Output queue for all output (lines, pauses, typewriter)
    private Queue<string> outputQueue = new Queue<string>();
    private bool isProcessingQueue = false;
    private bool pendingDialogueEnd = false; // <--- add this back

    // Static instance for external access (used by InkRunner flush)
    public static Home? Instance;

    private string listeningText = "Listening";
    private System.Threading.Timer? listeningTimer;
    private int listeningStep = 0;
    private readonly string[] listeningStates = new[] { "Listening", "Listening.", "Listening..", "Listening..." };
    private const int ListeningInterval = 400; // ms
    private const int ListeningPause = 600; // ms after 'Listening...'
    private bool listeningActive = false;
    private bool prevListeningActive = false;

    private void StartListeningAnimation()
    {
        listeningStep = 0;
        listeningText = listeningStates[0];
        listeningTimer?.Dispose();
        listeningTimer = new System.Threading.Timer(_ =>
        {
            listeningStep = (listeningStep + 1) % listeningStates.Length;
            listeningText = listeningStates[listeningStep];
            InvokeAsync(StateHasChanged);
            if (listeningStep == 0)
            {
                listeningTimer?.Change(ListeningPause, ListeningInterval);
            }
            else if (listeningStep == listeningStates.Length - 1)
            {
                listeningTimer?.Change(ListeningPause, (ListeningInterval + ListeningPause) / 2);
            }
            else
            {
                listeningTimer?.Change(ListeningInterval, ListeningInterval);
            }
        }, null, ListeningInterval, ListeningInterval);
    }

    private void StopListeningAnimation()
    {
        listeningTimer?.Dispose();
        listeningTimer = null;
        listeningText = listeningStates[0];
    }

    protected override void OnInitialized()
    {
        Instance = this;
        if (AppEnv == null)
        {
            throw new InvalidOperationException("AppEnvironment is not injected.");
        }
#if DEBUG
    var outputHandler = new WebOutputHandler(
    async line => EnqueueOutput(line),
    async () => { gameText = ""; await InvokeAsync(StateHasChanged); },
    async (type, msg) => EnqueueOutput($"[DEBUG - {type}]: {msg}")
    );
#else
        var outputHandler = new WebOutputHandler(
            async line => EnqueueOutput(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); }
        );
#endif

        var inputHandler = new WebInputHandler(
            async () => await Task.FromResult(userInput),
            async (choiceCount) => await GetDialogueChoice(choiceCount)
        );

        engine = new GameEngine(inputHandler, outputHandler, AppEnv);

        // Wire up callbacks for dialogue and player input
        if (GameContext.DialogueService != null)
        {
            GameContext.DialogueService.SetPlayerInputCallback(GetPlayerInputFromUIAsync);
            @* GameContext.DialogueService.DialogueComplete += async () =>
            {
                // Only set isInDialogue to false if not typewriting
                if (!isTypingDialogue)
                {
                    isInDialogue = false;
                    isAwaitingPlayerInput = false;
                    userInput = "";
                    await InvokeAsync(StateHasChanged);
                }
                // Otherwise, let the typewriter effect finish, then set isInDialogue = false at the end of HandleTypewriterEffect
            }; *@
            GameContext.DialogueService.DialogueStart += async () =>
                            {
                                isInDialogue = true;
                                isAwaitingPlayerInput = false;
                                userInput = "";
                                await InvokeAsync(StateHasChanged);
                            };
        }

        if (GameContext.InkRunner != null)
        {
            GameContext.InkRunner.OnDialogueEnd += () =>
            {
                isInDialogue = false;
                isAwaitingPlayerInput = false;
                userInput = "";
                InvokeAsync(StateHasChanged);
            };
        }

        // Do NOT start the game loop here; it will be started after fade.
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Auto-scroll to bottom on initial page load
            await Task.Delay(100); // Small delay to ensure DOM is ready
            await AutoScrollToBottom(force:true);
        }
        // Start/stop listening animation based on correct condition
        listeningActive = isInDialogue && !isAwaitingPlayerInput;
        if (listeningActive != prevListeningActive)
        {
            if (listeningActive)
                StartListeningAnimation();
            else
                StopListeningAnimation();
            prevListeningActive = listeningActive;
        }
    }

    private void ResetInput()
    {
        isAwaitingPlayerInput = false;
        userInput = "";
        isDialogueInput = false;
        InvokeAsync(StateHasChanged);
    }

    // Enqueue output for sequential processing
    private void EnqueueOutput(string line)
    {
#if DEBUG
        Console.WriteLine($"[DEBUG] EnqueueOutput: {line}");
#endif
        outputQueue.Enqueue(line);
        if (!isProcessingQueue)
        {
            _ = ProcessOutputQueue();
        }
    }

    /// <summary>
    /// Waits until the output queue is fully processed. Used to synchronize output and input.
    /// </summary>
    public async Task FlushOutputQueueAsync()
    {
        // Wait until the output queue is empty and not processing
        while (outputQueue.Count > 0 || isProcessingQueue)
        {
            await Task.Delay(1);
        }
    }

    private async Task ProcessOutputQueue()
    {
        isProcessingQueue = true;
        while (outputQueue.Count > 0)
        {
            var line = outputQueue.Dequeue();
            if (line == "__END__")
            {
                pendingDialogueEnd = true;
                continue;
            }
            if (line.Contains("__NL__"))
            {
                dialogueChoices.Clear();
                // Handle new line marker
                gameText += "\n";
                continue; // Do not add another new line after this
            }
#if DEBUG
            Console.WriteLine($"[DEBUG] ProcessOutputQueue: {line}");
#endif
            // Handle special pause marker: ms__PAUSE__
            if (line.TrimEnd().EndsWith(OutputConstants.TypewriterPauseMarker))
            {
                dialogueChoices.Clear();
                var msStr = line.Substring(0, line.IndexOf(OutputConstants.TypewriterPauseMarker));
                if (int.TryParse(msStr, out int ms))
                {
                    await InvokeAsync(StateHasChanged);
                    await Task.Yield();
                    #if DEBUG
                    await Task.Delay(Convert.ToInt32(Math.Round(ms * OutputConstants.DefaultDebugTypeSpeedModifier)));
                    #else
                    await Task.Delay(ms);
                    #endif
                }
                else
                {
                    await InvokeAsync(StateHasChanged);
                    await Task.Yield();
                    await Task.Delay(OutputConstants.DefaultPauseDuration);
                }
                continue; // Do not add pause marker to output buffer
            }
            // Handle typewriter effect
            if (line.Contains("__TYPEWRITER_START__") && line.Contains("__TYPEWRITER_END__"))
            {
                dialogueChoices.Clear();
                await HandleTypewriterEffect(line);
                continue;
            }
            // Dialogue choice line
            if (line.Trim().StartsWith("[") && line.Contains("]") && line.Trim().Length > 2)
            {
                int bracketEnd = line.IndexOf("]");
                if (bracketEnd > 0 && int.TryParse(line.Substring(1, bracketEnd - 1), out int choiceNumber))
                {
                    string choiceText = line.Substring(bracketEnd + 1).Trim();
                    if (!string.IsNullOrWhiteSpace(choiceText))
                    {
                        dialogueChoices.Add(choiceText);
                        await InvokeAsync(StateHasChanged);
                        await AutoScrollToBottom();
                        continue;
                    }
                }
            }
            // Normal line
            if (!string.IsNullOrWhiteSpace(line))
            {
                gameText += line + "\n";
            }
            else
            {
                gameText += "\n";
            }
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();
        }
        isProcessingQueue = false;

        // After all output is processed and typewriter is done
        if (pendingDialogueEnd && !isTypingDialogue)
        {
            Console.WriteLine($"[DEBUG] ProcessOutputQueue: Flushed output, ending dialogue at {DateTime.Now}");
            isInDialogue = false;
            isAwaitingPlayerInput = false;
            userInput = "";
            pendingDialogueEnd = false;
            GameContext.InkRunner?.DialogueFinishedOutputting();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleTypewriterEffect(string line)
    {
        // Parse ms value at the start of the line (e.g. "50__TYPEWRITER_START__...")
        int ms = OutputConstants.DefaultTypeSpeed; // default
        Console.WriteLine($"[DEBUG] Handling typewriter effect for line: {line}");
        int msEnd = line.IndexOf("__TYPEWRITER_START__");
        if (msEnd > 0)
        {
            string msStr = line.Substring(0, msEnd);
            if (!int.TryParse(msStr, out ms)) ms = OutputConstants.DefaultTypeSpeed;
        }
        Console.WriteLine($"[DEBUG] Typewriter effect with delay: {ms} ms");
        int startIndex = line.IndexOf("__TYPEWRITER_START__") + "__TYPEWRITER_START__".Length;
        int endIndex = line.IndexOf("__TYPEWRITER_END__");
        string message = line.Substring(startIndex, endIndex - startIndex);

        isTypingDialogue = true;
        await InvokeAsync(StateHasChanged);

        // Split into lines and type each line separately
        string[] lines = message.Split('\n');
        var buffer = gameText.Split('\n').ToList(); // Keep previous lines

        foreach (var msgLine in lines)
        {
            string typedLine = "";
            for (int i = 0; i < msgLine.Length; i++)
            {
                typedLine += msgLine[i];
                gameText = string.Join('\n', buffer) + (buffer.Count > 0 ? "\n" : "") + typedLine;
                await InvokeAsync(StateHasChanged);
                await AutoScrollToBottom();
                char letter = msgLine[i];
                bool isEnd = message.Count() == i + 1 || message[i + 1].Equals(' ') || (i + 2 == message.Length && message.Substring(i + 1).Equals("\n")); // Check if this is the end of the message or sentence

#if DEBUG
                await Task.Delay(CharacterOutputDelayCalculator.CalculateDebugDelay(letter, ms, isEnd));
#else
                await Task.Delay(CharacterOutputDelayCalculator.CalculateDelay(letter, ms, isEnd));
#endif
            }
            buffer.Add(typedLine); // Add finished line to buffer
            gameText = string.Join('\n', buffer);
            await InvokeAsync(StateHasChanged);
            await AutoScrollToBottom();

#if DEBUG
            await Task.Delay(Convert.ToInt32(Math.Round(ms * OutputConstants.NewLinePauseMultiplier * OutputConstants.DefaultDebugTypeSpeedModifier)));
#else
            await Task.Delay(ms * OutputConstants.NewLinePauseMultiplier);
#endif
        }
        isTypingDialogue = false;
        await InvokeAsync(StateHasChanged);

        // After typewriter effect, if pendingDialogueEnd is set and output queue is empty, end dialogue
        if (pendingDialogueEnd && !isProcessingQueue)
        {
            Console.WriteLine($"[DEBUG] HandleTypewriterEffect: Flushed output, ending dialogue at {DateTime.Now}");
            isInDialogue = false;
            isAwaitingPlayerInput = false;
            userInput = "";
            pendingDialogueEnd = false;
            GameContext.InkRunner?.DialogueFinishedOutputting();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task<int> GetDialogueChoice(int choiceCount)
    {
        Console.WriteLine($"[DEBUG] GetDialogueChoice called with count={choiceCount} at {DateTime.Now}, isInDialogue={isInDialogue}");
        choiceCompletionSource = new TaskCompletionSource<int>();
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);

        // Wait for output queue to be fully processed so choices are visible
        if (Instance != null)
            await Instance.FlushOutputQueueAsync();

        int choice = await choiceCompletionSource.Task;
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);

        // Defensive: If the story is finished after the choice, do not return a choice
        if (GameContext.InkRunner == null || 
            (GameContext.InkRunner.Story != null && 
             !GameContext.InkRunner.Story.canContinue && 
             (GameContext.InkRunner.Story.currentChoices == null || GameContext.InkRunner.Story.currentChoices.Count == 0)))
        {
            Console.WriteLine("[DEBUG] GetDialogueChoice: Story is finished after waiting, not returning a choice.");
            return -1;
        }

        return choice;
    }

    private async Task SelectDialogueChoice(int choice)
    {
        choiceCompletionSource?.TrySetResult(choice);
    }

    private async Task<string> GetPlayerInputFromUIAsync(bool isDialogue)
    {
        playerInputTcs = new TaskCompletionSource<string>();
        isAwaitingPlayerInput = true;
        isDialogueInput = isDialogue;
        await InvokeAsync(StateHasChanged);
        return await playerInputTcs.Task;
    }

    private async Task HandleInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(userInput))
        {
            if (isAwaitingPlayerInput && playerInputTcs != null)
            {
                playerInputTcs.TrySetResult(userInput);
                isAwaitingPlayerInput = false;
                userInput = "";
                await InvokeAsync(StateHasChanged);
                return;
            }
            try
            {
                EnqueueOutput($"> {userInput}");
                string command = userInput.Trim();
                #if DEBUG
                EnqueueOutput($"[DEBUG] Executing command: '{command}'");
                EnqueueOutput($"[DEBUG] Player location: {GameContext.Player.CurrentLocation.Name}");
                EnqueueOutput($"[DEBUG] Player sublocation: {(GameContext.Player.CurrentSublocation?.Name.ReferenceName ?? "None")}");
                EnqueueOutput($"[DEBUG] Sublocation object: {(GameContext.Player.CurrentSublocation?.GameObject?.GetType().Name ?? "None")}");
                #endif
                engine.ReceiveCommand(command);
                #if DEBUG
                EnqueueOutput($"[DEBUG] Command execution completed");
                #endif
            }
            catch (Exception ex)
            {
                #if DEBUG
                EnqueueOutput($"[ERROR] Command execution failed: {ex.Message}");
                EnqueueOutput($"[ERROR] Stack trace: {ex.StackTrace}");
                #endif
            }
            finally
            {
                userInput = "";
            }
        }
    }

    private async Task AutoScrollToBottom(bool force = false)
    {
        try
        {
            if (JS != null)
            {
                await JS.InvokeVoidAsync("scrollGameOutputToBottom", force);
                await Task.Delay(10);
            }
        }
        catch (Exception ex)
        {
            gameText += $"\n[ERROR] JS interop failed: {ex.Message}\n";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async void BeginGame()
    {
        isFading = true;
        StateHasChanged();
        engine.StartGameLoopAsync(); // Start the game loop immediately
        await Task.Delay(FadeDurationMs);
        hasStarted = true;
        isFading = false;
        StateHasChanged();
    }
}
