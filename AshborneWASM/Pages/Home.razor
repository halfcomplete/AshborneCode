@using AshborneGame._Core.Game
@using AshborneGame.WebPort
@page "/"

<h1 class="text-center">ASHBORNE</h1>

<div class="game-screen">
    <div class="game-output">@gameText</div>

    @if (isInDialogue && dialogueChoices.Count > 0 && !isTypingDialogue)
    {
        <div class="dialogue-choices">
            <p>Choose an option:</p>
            @for (int i = 0; i < dialogueChoices.Count; i++)
            {
                int choiceIndex = i; // Capture the index for the lambda
                <button @onclick="() => SelectDialogueChoice(choiceIndex + 1)" class="choice-button">
                    [@(choiceIndex + 1)] @dialogueChoices[i]
                </button>
            }
        </div>
    }
    else if (!isInDialogue)
    {
        <input @bind="userInput"
               @bind:event="oninput"
               @onkeydown="HandleInput"
               placeholder="What will you do?" />
    }
    else
    {
        <div class="dialogue-waiting">
            <p>Listening...</p>
        </div>
    }
</div>

@code {
    private string userInput = "";
    private string gameText = "";
    private GameEngine engine;
    private bool isInDialogue = false;
    private bool isTypingDialogue = false;
    private List<string> dialogueChoices = new List<string>();
    private TaskCompletionSource<int> choiceCompletionSource;

    protected override void OnInitialized()
    {
        #if DEBUG
        var outputHandler = new WebOutputHandler(
            async line => await AppendLine(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); },
            async (type, msg) => await AppendLine($"[DEBUG - {type}]: {msg}")
        );
        #else
        var outputHandler = new WebOutputHandler(
            async line => await AppendLine(line),
            async () => { gameText = ""; await InvokeAsync(StateHasChanged); }
        );
        #endif

        var inputHandler = new WebInputHandler(
            async () => await Task.FromResult(userInput),
            async (choiceCount) => await GetDialogueChoice(choiceCount)
        );

        engine = new GameEngine(inputHandler, outputHandler);
        
        // Start the game without the blocking loop
        engine.StartGameLoopAsync();
    }

    private async Task<int> GetDialogueChoice(int choiceCount)
    {
        // Create a completion source for this choice
        choiceCompletionSource = new TaskCompletionSource<int>();
        
        // Set dialogue state and wait for choices to be populated
        isInDialogue = true;
        await InvokeAsync(StateHasChanged);
        
        // Wait for choices to be populated (with timeout to prevent infinite wait)
        int timeout = 0;
        while (dialogueChoices.Count == 0 && timeout < 1000) // 10 second timeout
        {
            await Task.Delay(10);
            timeout++;
        }
        
        if (dialogueChoices.Count == 0)
        {
            // If no choices were detected, return 1 as fallback
            isInDialogue = false;
            await InvokeAsync(StateHasChanged);
            return 1;
        }
        
        // Wait for the user to make a choice
        int choice = await choiceCompletionSource.Task;
        
        // Clear dialogue state
        isInDialogue = false;
        dialogueChoices.Clear();
        await InvokeAsync(StateHasChanged);
        
        return choice;
    }

    private async Task SelectDialogueChoice(int choice)
    {
        choiceCompletionSource?.TrySetResult(choice);
    }

    private async Task AppendLine(string line)
    {
        // Check if this is a dialogue choice line (format: [1] Choice text)
        if (line.Trim().StartsWith("[") && line.Contains("]"))
        {
            int bracketEnd = line.IndexOf("]");
            if (bracketEnd > 0 && int.TryParse(line.Substring(1, bracketEnd - 1), out int choiceNumber))
            {
                string choiceText = line.Substring(bracketEnd + 1).Trim();
                dialogueChoices.Add(choiceText);
                // Don't immediately show choices - wait for dialogue to complete
                await InvokeAsync(StateHasChanged);
                return;
            }
        }

        // Check if this is a typewriter effect message
        if (line.Contains("__TYPEWRITER_START__") && line.Contains("__TYPEWRITER_END__"))
        {
            await HandleTypewriterEffect(line);
        }
        else
        {
            // Don't add empty lines or lines that are just whitespace
            if (!string.IsNullOrWhiteSpace(line))
            {
                gameText += line + "\n";
            }
            else
            {
                gameText += "\n";
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleTypewriterEffect(string line)
    {
        // Extract the message from the typewriter markers
        int startIndex = line.IndexOf("__TYPEWRITER_START__") + "__TYPEWRITER_START__".Length;
        int endIndex = line.IndexOf("__TYPEWRITER_END__");
        string message = line.Substring(startIndex, endIndex - startIndex);
        
        // Set typing state to prevent choices from showing
        isTypingDialogue = true;
        await InvokeAsync(StateHasChanged);
        
        // Add the message to gameText without the markers
        gameText += message + "\n";
        await InvokeAsync(StateHasChanged);
        
        // Now implement the typewriter effect
        string currentText = gameText;
        string targetText = currentText.Substring(0, currentText.Length - message.Length - 1); // Remove the message we just added
        
        for (int i = 0; i < message.Length; i++)
        {
            targetText += message[i];
            gameText = targetText + "\n";
            await InvokeAsync(StateHasChanged);
            
            // Add delays for typewriter effect
            char currentChar = message[i];
            if ((currentChar == '.' || currentChar == ':' || currentChar == '"' || currentChar == ']') &&
                (i == message.Length - 1 || message[i + 1] == ' ' || message[i + 1] == '\n'))
            {
                await Task.Delay(800);
            }
            else
            {
                await Task.Delay(50); // Faster for web
            }
        }
        
        await Task.Delay(200);
        
        // Clear typing state to allow choices to show
        isTypingDialogue = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(userInput))
        {
            try
            {
                await AppendLine($"\n> {userInput}\n");
                string command = userInput.Trim();
                await AppendLine($"[DEBUG] Executing command: '{command}'");
                await AppendLine($"[DEBUG] Player location: {GameContext.Player.CurrentLocation.Name}");
                await AppendLine($"[DEBUG] Player sublocation: {(GameContext.Player.CurrentSublocation?.Name ?? "None")}");
                await AppendLine($"[DEBUG] Sublocation object: {(GameContext.Player.CurrentSublocation?.Object?.GetType().Name ?? "None")}");
                engine.ReceiveCommand(command);
                await AppendLine($"[DEBUG] Command execution completed");
            }
            catch (Exception ex)
            {
                await AppendLine($"[ERROR] Command execution failed: {ex.Message}");
                await AppendLine($"[ERROR] Stack trace: {ex.StackTrace}");
            }
            finally
            {
                userInput = "";
            }
        }
    }
}
